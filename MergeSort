#include <iostream>
#include <vector>
#include <queue>

using namespace std;

void Merge(queue<int>&Q, vector<int>&A, int&index_1, int&index_2, int param_1, int param_2)
{
    Q.push(A[index_2]);
    
    if (index_2 < param_2) // если не дошел до конца. Увеличиваем 
    {
        index_2++;
    }
    
    else if (index_2 == param_2) // Если дошел, перекидываем оставшиеся в очередь
    {
        for (int f = index_1; f <= param_1; f++)
            Q.push(A[f]);
    } 
}

int main()
{
    int n, a; /// исходное кол-во элементов, вспомогательная штука
    cout << "n = ";
    cin >> n;
    
    int ost = n; /// кол-во несортированных элементов очереди
    int vinut = 2; // счетчик 2 4 8 16 32.... стандартный размер кусочка
    int p = 0; // размерность кусочка
    
    vector<int> A(n);
    queue<int> Q;
    
    
    cout << "vector A" << endl; // вводим сразу в очередь
    for (int i = 0; i < n; i++)
    {
        cin >> a;
        Q.push(a);
    }
    
    while (p != n) /// пока размер кусочка != размеру очереди
    {
        if (ost == 0) // если отсортировали все элементы в очереди, тогда переприсваеваем ost и увеличиваем шаг vinut
        {
            ost = n;
            vinut *= 2;
        }
        
        if (vinut <= ost) // если шаг <= остатку несортированных, тогда меняем размерность кусочка на шаг, и уменьшаем кол-во несортированных на размер кусочка
        {
            p = vinut;
            ost -= p;
        }
        
        else if (vinut > ost) // если шаг > остатка несортированных, тогда меняем размерность кусочка на остаток, и уменьшаем кол-во несортированных на размер кусочка
        {
            p = ost;
            ost -= p;
        }
        
        A.resize(p); //  Меняем размерность вектора на размерность кусочка
            
        for (int i = 0; i < p; i++) // заполняем кусочек элементами очереди, попутно вынимая из нее элементы
        {
            A[i] = Q.front();
            Q.pop();
        }
        
        if (p == 1) // миникостыль)) Если кусочек из 1 элемента, сразу кидаем его в конец очереди
        {
            Q.push(A[0]);
            continue;
        }
        
        int i = 0; // {0, ..., i, ..., m - 1, (j = m), ..., r} --- кусочек
        int r = p - 1;
        int m = vinut / 2;
        
        if (m > r) // Еще миникостыль)) Если начало для j -- выходит за границы кусочка, тогда начало = последний элмент кусочка
            m = r;
        
        int j = m;
        
        while (Q.size() < n)   /////// пока очередь не заполнится до исходного ==> делаем штуки
        {
            
            if (A[i] >= A[j])
            {
                Merge(Q, A, i, j, (m - 1), r);
            }

             else if (A[i] <= A[j])
            {
                
               Merge(Q, A, j, i, r, (m - 1));
                
            }   
 
            
        }
 
        
    }
    
    cout << endl << endl << "vector A after sort" << endl;
    
    for (int i = 0; i < n; i++) // Вывод ответа
    {
        cout << Q.front() << " ";
        Q.pop();
    }

    return 0;
}
